### 多线程面试题

---

## 一、基础题

### 1. 创建线程的几种方式？

```java
// 方式1：继承 Thread
class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行代码
    }
}
new MyThread().start();

// 方式2：实现 Runnable
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行代码
    }
}
new Thread(new MyRunnable()).start();

// 方式3：实现 Callable（有返回值）
class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "线程返回值";
    }
}
FutureTask<String> task = new FutureTask<>(new MyCallable());
new Thread(task).start();
task.get();  // 获取返回值

// 方式4：使用线程池
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.submit(() -> {
    // Lambda 表达式
});
```

### 2. start() 和 run() 的区别？

- **start()**：启动新线程，JVM 会调用线程的 run() 方法
- **run()**：普通方法，在当前线程执行，不会启动新线程

```java
// ❌ 错误：在当前线程执行run()
new Thread().run();

// ✅ 正确：启动新线程
new Thread().start();
```

### 3. 线程的状态有哪些？

```
NEW (新建)
    ↓ start()
RUNNABLE (可运行)
    ↓ 获取CPU时间片
RUNNING (运行中)
    ↓ 主动 yield() 或失去CPU时间片
    ↓
    ├─ BLOCKED (阻塞) - 等待锁
    ├─ WAITING (等待) - wait()/join()/park()
    └─ TIMED_WAITING (计时等待) - sleep()/wait(timeout)
    ↓ 获取锁或等待结束
RUNNABLE
    ↓ 线程结束
TERMINATED (终止)
```

### 4. 线程的基本方法有哪些？

| 方法 | 作用 | 是否释放锁 |
|------|------|-----------|
| `sleep()` | 暂停当前线程 | 否 |
| `yield()` | 让出CPU | 否 |
| `join()` | 等待线程结束 | 否 |
| `wait()` | 等待通知 | 是 |
| `notify()` | 唤醒线程 | 否 |
| `notifyAll()` | 唤醒所有等待线程 | 否 |
| `interrupt()` | 中断线程 | 否 |

---

## 二、同步机制

### 5. synchronized 关键字？

```java
// 方式1：实例方法（锁当前对象实例）
public synchronized void method() {
    // 代码
}

// 方式2：静态方法（锁当前类对象）
public static synchronized void staticMethod() {
    // 代码
}

// 方式3：代码块（锁指定对象）
public void method() {
    synchronized (this) {
        // 代码
    }
    synchronized (MyClass.class) {
        // 锁类对象
    }
    synchronized (lock) {
        // 锁任意对象
    }
}
```

**特点**：
- 不可中断
- 非公平锁
- 一次只允许一个线程访问

### 6. Lock 和 synchronized 的区别？

| 特性 | synchronized | Lock |
|------|-------------|------|
| 锁获取方式 | JVM 自动 | 手动 lock()/unlock() |
| 锁释放 | 自动释放 | 必须在 finally 中释放 |
| 可中断性 | 不可中断 | 可中断（lockInterruptibly()） |
| 公平性 | 非公平 | 可选公平/非公平 |
| 条件变量 | 1 个（wait/notify） | 多个（Condition） |
| 超时获取 | 不支持 | 支持（tryLock(timeout)） |

**使用建议**：Lock 功能更强大，但需要手动管理，推荐使用 `try-finally` 确保释放锁。

### 7. 死锁产生的四个必要条件？

```
1. 互斥条件：资源不能同时被多个线程使用
2. 占有并等待：线程已获得资源，等待其他资源
3. 不可抢占：资源不能被强制抢占
4. 循环等待：存在等待环路
```

**避免死锁**：
- 破坏互斥条件（通常做不到）
- 破坏占有并等待：一次性申请所有资源
- 破坏不可抢占：允许抢占
- 破坏循环等待：按顺序申请资源

### 8. 如何检测死锁？

```java
// 使用 ThreadMXBean 检测
ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
long[] deadlockedThreads = threadBean.findDeadlockedThreads();
if (deadlockedThreads != null) {
    System.out.println("发现死锁线程: " + Arrays.toString(deadlockedThreads));
}
```

---

## 三、线程池

### 9. 线程池的核心参数？

```java
ThreadPoolExecutor(
    int corePoolSize,        // 核心线程数
    int maximumPoolSize,     // 最大线程数
    long keepAliveTime,      // 空闲存活时间
    TimeUnit unit,           // 时间单位
    BlockingQueue<Runnable> workQueue,  // 任务队列
    ThreadFactory threadFactory,       // 线程工厂
    RejectedExecutionHandler handler   // 拒绝策略
)
```

### 10. Executors 提供的线程池类型？

```java
// 固定大小线程池
ExecutorService pool1 = Executors.newFixedThreadPool(10);

// 单线程线程池
ExecutorService pool2 = Executors.newSingleThreadExecutor();

// 缓存线程池（自动扩容）
ExecutorService pool3 = Executors.newCachedThreadPool();

// 定时线程池
ScheduledExecutorService pool4 = Executors.newScheduledThreadPool(10);

// 创建定时任务
pool4.schedule(() -> System.out.println("延迟1秒"), 1, TimeUnit.SECONDS);
pool4.scheduleAtFixedRate(() -> System.out.println("每2秒执行"), 0, 2, TimeUnit.SECONDS);
```

### 11. 为什么阿里巴巴推荐使用 ThreadPoolExecutor 而不是 Executors？

**原因**：
- `newFixedThreadPool`：无界队列，可能导致 OOM
- `newCachedThreadPool`：无界线程数，可能导致 OOM
- `newSingleThreadExecutor`：无界队列，可能导致 OOM

**推荐写法**：
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,
    maximumPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(queueCapacity),
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.CallerRunsPolicy()
);
```

### 12. 线程池的拒绝策略有哪些？

| 策略 | 行为 | 适用场景 |
|------|------|---------|
| `AbortPolicy` | 抛出 RejectedExecutionException | 默认，任务重要 |
| `CallerRunsPolicy` | 由调用线程执行 | 提供背压，任务不能丢失 |
| `DiscardPolicy` | 静默丢弃 | 任务不重要 |
| `DiscardOldestPolicy` | 丢弃最老任务，重试 | 容忍丢失部分任务 |

---

## 四、volatile 和 CAS

### 13. volatile 的作用？

```java
private volatile boolean flag = false;

// 保证可见性
flag = true;  // 立即同步到主内存，其他线程立即可见

// 不保证原子性
volatile int count = 0;
count++;  // 不是一个原子操作

// 禁止指令重排
volatile Singleton singleton = new Singleton();  // 双重检查锁定
```

**适用场景**：
- 标志位
- 单例模式的双重检查
- 状态标志

**不适用场景**：
- 需要保证原子性的操作（如计数器）
- 复合操作

### 14. CAS (Compare And Swap) 原理？

```java
// AtomicInteger 的底层实现
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}

// CAS 操作：如果期望值等于当前值，则更新
// V: 变量内存地址
// Expected: 期望值
// New: 新值
// CAS(V, Expected, New) {
//     if (V == Expected) {
//         V = New;
//         return true;
//     }
//     return false;
// }
```

**优点**：
- 无锁，性能高
- 不会出现线程阻塞

**缺点**：
- ABA 问题（版本号解决）
- 自旋消耗 CPU
- 只能保证单个变量的原子性

### 15. 什么是 ABA 问题？如何解决？

```java
// ABA 问题示例
AtomicInteger atomicInt = new AtomicInteger(100);

Thread t1 = new Thread(() -> {
    atomicInt.compareAndSet(100, 101);  // 100 -> 101
    atomicInt.compareAndSet(101, 100);  // 101 -> 100
});

Thread t2 = new Thread(() -> {
    boolean success = atomicInt.compareAndSet(100, 200);  // 成功，但中间经历了变化
    System.out.println("CAS结果: " + success);  // true
});

// 解决方案：使用 AtomicStampedReference 带版本号的引用
AtomicStampedReference<Integer> stampedRef = new AtomicStampedReference<>(100, 0);

// 获取当前值和版本号
int[] stampHolder = new int[1];
int currentValue = stampedRef.get(stampHolder);
int currentStamp = stampHolder[0];

// CAS 操作
stampedRef.compareAndSet(currentValue, newValue, currentStamp, currentStamp + 1);
```

---

## 五、并发工具类

### 16. CountDownLatch 的使用？

```java
// 等待多个线程完成
CountDownLatch latch = new CountDownLatch(3);

// 工作线程
for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        System.out.println("工作完成");
        latch.countDown();
    }).start();
}

// 主线程等待所有工作线程完成
latch.await();  // 阻塞直到计数器为0
System.out.println("所有工作完成");
```

### 17. CyclicBarrier 的使用？

```java
// 多个线程互相等待，达到屏障点后继续
CyclicBarrier barrier = new CyclicBarrier(3);

for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        try {
            System.out.println(Thread.currentThread().getName() + " 到达屏障");
            barrier.await();  // 等待其他线程到达
            System.out.println(Thread.currentThread().getName() + " 继续执行");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }).start();
}
```

**区别**：
- `CountDownLatch`：一次性，倒计数
- `CyclicBarrier`：可重复使用，互相等待

### 18. Semaphore 的使用？

```java
// 控制并发数量
Semaphore semaphore = new Semaphore(3);  // 最多3个线程同时访问

for (int i = 0; i < 10; i++) {
    new Thread(() -> {
        try {
            semaphore.acquire();  // 获取许可
            System.out.println(Thread.currentThread().getName() + " 获取许可");
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + " 释放许可");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();  // 释放许可
        }
    }).start();
}
```

### 19. Exchanger 的使用？

```java
// 两个线程交换数据
Exchanger<String> exchanger = new Exchanger<>();

Thread t1 = new Thread(() -> {
    try {
        String data = "来自线程1的数据";
        System.out.println("线程1发送: " + data);
        String received = exchanger.exchange(data);
        System.out.println("线程1收到: " + received);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

Thread t2 = new Thread(() -> {
    try {
        String data = "来自线程2的数据";
        System.out.println("线程2发送: " + data);
        String received = exchanger.exchange(data);
        System.out.println("线程2收到: " + received);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

t1.start();
t2.start();
```

---

## 六、JUC 集合

### 20. ConcurrentHashMap 的实现原理？

**Java 7**：分段锁
- 默认 16 个 Segment
- 每个 Segment 是一个独立的 ReentrantLock
- 不同线程可同时操作不同 Segment

**Java 8**：CAS + synchronized
- 取消 Segment，直接锁数组节点
- 首节点用 synchronized
- 其他节点用 CAS

### 21. CopyOnWriteArrayList 的原理？

```java
// 写时复制
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

// 读操作无锁
public E get(int index) {
    return get(getArray(), index);
}
```

**适用场景**：读多写少

### 22. ConcurrentLinkedQueue 如何实现线程安全？

```java
// CAS 操作实现无锁
public boolean offer(E e) {
    checkNotNull(e);
    Node<E> newNode = new Node<E>(e);
    Node<E> t = tail;
    Node<E> p = t;
    while (true) {
        Node<E> q = p.next;
        if (q == null) {
            if (p.casNext(null, newNode)) {
                // CAS 成功
                if (p != t) casTail(t, newNode);
                return true;
            }
        }
        // CAS 失败，重试
    }
}
```

---

## 七、高级特性

### 23. ThreadLocal 的原理和使用场景？

```java
// ThreadLocal 使用
private static final ThreadLocal<DateFormat> df =
    ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

public String formatDate(Date date) {
    return df.get().format(date);
}

// 清理资源
public void cleanup() {
    df.remove();
}
```

**原理**：
- 每个线程维护一个 ThreadLocalMap
- ThreadLocalMap 的 key 是 ThreadLocal 对象
- value 是线程私有数据

**使用场景**：
- 数据库连接池
- Session 管理
- 事务管理

### 24. 什么是可重入锁？

```java
// 可重入锁：同一个线程可以多次获取同一个锁
class ReentrantLockDemo {
    private final ReentrantLock lock = new ReentrantLock();

    public void method1() {
        lock.lock();  // 第一次获取锁
        try {
            method2();  // 第二次获取锁
        } finally {
            lock.unlock();
        }
    }

    public void method2() {
        lock.lock();  // 可重入
        try {
            // 执行代码
        } finally {
            lock.unlock();
        }
    }
}
```

### 25. 读写锁（ReentrantReadWriteLock）？

```java
private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

// 读锁（共享）
public void read() {
    rwLock.readLock().lock();
    try {
        // 多个线程可同时读取
    } finally {
        rwLock.readLock().unlock();
    }
}

// 写锁（排他）
public void write() {
    rwLock.writeLock().lock();
    try {
        // 只有一个线程可写入
    } finally {
        rwLock.writeLock().unlock();
    }
}
```

**锁降级**：写锁 → 读锁 → 释放写锁

---

## 八、设计模式

### 26. 线程池的创建模式？

```java
// 线程池创建工厂
public class ThreadPoolFactory {
    private static final int CORE_POOL_SIZE = Runtime.getRuntime().availableProcessors();
    private static final int MAX_POOL_SIZE = CORE_POOL_SIZE * 2;
    private static final int QUEUE_CAPACITY = 1000;

    public static ThreadPoolExecutor createFixedThreadPool() {
        return new ThreadPoolExecutor(
            CORE_POOL_SIZE,
            MAX_POOL_SIZE,
            60L,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(QUEUE_CAPACITY),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}
```

### 27. 生产者消费者模式？

```java
// 使用阻塞队列实现
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);

class Producer extends Thread {
    @Override
    public void run() {
        try {
            for (int i = 0; i < 100; i++) {
                queue.put(i);  // 队列满时阻塞
                System.out.println("生产: " + i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Consumer extends Thread {
    @Override
    public void run() {
        try {
            while (true) {
                Integer i = queue.take();  // 队列空时阻塞
                System.out.println("消费: " + i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 28. 单例模式（线程安全）？

```java
// 方式1：饿汉式（线程安全，类加载时初始化）
class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

// 方式2：懒汉式（线程不安全，需要加锁）
class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

// 方式3：双重检查锁定（推荐）
class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

---

## 九、代码题

### 29. 手写线程池？

```java
public class MyThreadPool {
    private BlockingQueue<Runnable> workQueue;
    private List<Worker> workers;
    private volatile boolean isShutdown = false;

    public MyThreadPool(int coreSize, int queueSize) {
        this.workQueue = new ArrayBlockingQueue<>(queueSize);
        this.workers = new ArrayList<>(coreSize);

        for (int i = 0; i < coreSize; i++) {
            Worker worker = new Worker();
            worker.start();
            workers.add(worker);
        }
    }

    public void execute(Runnable task) {
        if (isShutdown) {
            throw new IllegalStateException("线程池已关闭");
        }

        try {
            workQueue.put(task);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    public void shutdown() {
        isShutdown = true;
    }

    private class Worker extends Thread {
        @Override
        public void run() {
            while (!isShutdown || !workQueue.isEmpty()) {
                try {
                    Runnable task = workQueue.take();
                    task.run();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}
```

### 30. 实现一个限流器（令牌桶）？

```java
public class RateLimiter {
    private final long rate;  // 速率：令牌/秒
    private final long capacity;  // 桶容量
    private volatile long tokens;  // 当前令牌数
    private volatile long lastUpdate;  // 最后更新时间

    public RateLimiter(long rate, long capacity) {
        this.rate = rate;
        this.capacity = capacity;
        this.tokens = capacity;
        this.lastUpdate = System.currentTimeMillis();
    }

    public synchronized boolean acquire() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastUpdate;

        // 补充令牌
        tokens = Math.min(capacity, tokens + elapsed * rate / 1000);
        lastUpdate = now;

        if (tokens > 0) {
            tokens--;
            return true;
        }
        return false;
    }
}
```

### 31. 实现一个线程安全的计数器？

```java
// 方式1：synchronized
class Counter1 {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

// 方式2：AtomicInteger
class Counter2 {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}

// 方式3：LongAdder（高并发时性能更好）
class Counter3 {
    private final LongAdder count = new LongAdder();

    public void increment() {
        count.increment();
    }

    public int getCount() {
        return count.intValue();
    }
}
```

---

## 十、高频面试题速记

1. **创建线程的4种方式**：Thread、Runnable、Callable、线程池
2. **synchronized vs Lock**：Lock 更灵活，支持中断、公平性
3. **线程池核心参数**：corePoolSize、maximumPoolSize、队列、拒绝策略
4. **volatile 的三大特性**：可见性、禁止指令重排、不保证原子性
5. **CAS 问题**：ABA 问题（使用版本号解决）
6. **ConcurrentHashMap**：Java 7 分段锁，Java 8 CAS + synchronized
7. **CopyOnWriteArrayList**：写时复制，读多写少场景
8. **ThreadLocal**：线程局部变量，解决并发安全问题
9. **锁的升级**：无锁 → 偏向锁 → 轻量级锁 → 重量级锁
10. **死锁的4个条件**：互斥、占有并等待、不可抢占、循环等待

---

## 十一、综合题

### 32. 设计一个异步任务框架？

```java
public class AsyncTaskFramework {
    private final ThreadPoolExecutor executor;
    private final List<Future<?>> futures = new ArrayList<>();

    public AsyncTaskFramework(int corePoolSize) {
        this.executor = new ThreadPoolExecutor(
            corePoolSize,
            corePoolSize * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }

    public void execute(Runnable task) {
        futures.add(executor.submit(task));
    }

    public List<Object> getAllResults() throws ExecutionException, InterruptedException {
        List<Object> results = new ArrayList<>();
        for (Future<?> future : futures) {
            if (future.isDone()) {
                results.add(future.get());
            }
        }
        return results;
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

### 33. 如何优雅地停止线程？

```java
class StoppableTask implements Runnable {
    private volatile boolean running = true;

    public void stop() {
        running = false;
    }

    @Override
    public void run() {
        while (running) {
            try {
                // 执行任务
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
}

// 或者使用 interrupt()
class InterruptibleTask implements Runnable {
    @Override
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                // 执行任务
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("线程被中断，退出循环");
                break;
            }
        }
    }
}
```

### 34. 读写锁实现缓存系统？

```java
class Cache<K, V> {
    private final Map<K, V> cache = new HashMap<>();
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public V get(K key) {
        rwLock.readLock().lock();
        try {
            return cache.get(key);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void put(K key, V value) {
        rwLock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    public void clear() {
        rwLock.writeLock().lock();
        try {
            cache.clear();
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
```

---

## 十二、必考知识点总结

1. **synchronized**：JVM 实现，不可中断
2. **Lock**：JUC 实现，可中断、公平性
3. **volatile**：可见性、禁止重排、不保证原子性
4. **CAS**：无锁，ABA 问题
5. **线程池**：参数、拒绝策略、OOM 风险
6. **ConcurrentHashMap**：实现原理、线程安全
7. **ThreadLocal**：内存泄漏、使用场景
8. **死锁**：四个条件、避免策略
9. **volatile vs synchronized**：volatile 不保证原子性，synchronized 保证
10. **线程状态**：6种状态的转换